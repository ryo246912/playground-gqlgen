package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"

	"github.com/uptrace/bun"
)

// Rental represents a row from 'sakila.rental'.
type Rental struct {
	bun.BaseModel `bun:"table:rental"`

	RentalID    int          `json:"rental_id"`    // rental_id
	RentalDate  time.Time    `json:"rental_date"`  // rental_date
	InventoryID uint         `json:"inventory_id"` // inventory_id
	CustomerID  uint16       `json:"customer_id"`  // customer_id
	ReturnDate  sql.NullTime `json:"return_date"`  // return_date
	StaffID     uint8        `json:"staff_id"`     // staff_id
	LastUpdate  time.Time    `json:"last_update"`  // last_update
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Rental] exists in the database.
func (r *Rental) Exists() bool {
	return r._exists
}

// Deleted returns true when the [Rental] has been marked for deletion
// from the database.
func (r *Rental) Deleted() bool {
	return r._deleted
}

// Insert inserts the [Rental] to the database.
func (r *Rental) Insert(ctx context.Context, db DB) error {
	switch {
	case r._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case r._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sakila.rental (` +
		`rental_date, inventory_id, customer_id, return_date, staff_id, last_update` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate)
	res, err := db.ExecContext(ctx, sqlstr, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	r.RentalID = int(id)
	// set exists
	r._exists = true
	return nil
}

// Update updates a [Rental] in the database.
func (r *Rental) Update(ctx context.Context, db DB) error {
	switch {
	case !r._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case r._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE sakila.rental SET ` +
		`rental_date = ?, inventory_id = ?, customer_id = ?, return_date = ?, staff_id = ?, last_update = ? ` +
		`WHERE rental_id = ?`
	// run
	logf(sqlstr, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate, r.RentalID)
	if _, err := db.ExecContext(ctx, sqlstr, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate, r.RentalID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Rental] to the database.
func (r *Rental) Save(ctx context.Context, db DB) error {
	if r.Exists() {
		return r.Update(ctx, db)
	}
	return r.Insert(ctx, db)
}

// Upsert performs an upsert for [Rental].
func (r *Rental) Upsert(ctx context.Context, db DB) error {
	switch {
	case r._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sakila.rental (` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`rental_date = VALUES(rental_date), inventory_id = VALUES(inventory_id), customer_id = VALUES(customer_id), return_date = VALUES(return_date), staff_id = VALUES(staff_id), last_update = VALUES(last_update)`
	// run
	logf(sqlstr, r.RentalID, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate)
	if _, err := db.ExecContext(ctx, sqlstr, r.RentalID, r.RentalDate, r.InventoryID, r.CustomerID, r.ReturnDate, r.StaffID, r.LastUpdate); err != nil {
		return logerror(err)
	}
	// set exists
	r._exists = true
	return nil
}

// Delete deletes the [Rental] from the database.
func (r *Rental) Delete(ctx context.Context, db DB) error {
	switch {
	case !r._exists: // doesn't exist
		return nil
	case r._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM sakila.rental ` +
		`WHERE rental_id = ?`
	// run
	logf(sqlstr, r.RentalID)
	if _, err := db.ExecContext(ctx, sqlstr, r.RentalID); err != nil {
		return logerror(err)
	}
	// set deleted
	r._deleted = true
	return nil
}

// RentalByCustomerID retrieves a row from 'sakila.rental' as a [Rental].
//
// Generated from index 'idx_fk_customer_id'.
func RentalByCustomerID(ctx context.Context, db DB, customerID uint16) ([]*Rental, error) {
	// query
	const sqlstr = `SELECT ` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update ` +
		`FROM sakila.rental ` +
		`WHERE customer_id = ?`
	// run
	logf(sqlstr, customerID)
	rows, err := db.QueryContext(ctx, sqlstr, customerID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Rental
	for rows.Next() {
		r := Rental{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&r.RentalID, &r.RentalDate, &r.InventoryID, &r.CustomerID, &r.ReturnDate, &r.StaffID, &r.LastUpdate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &r)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// RentalByInventoryID retrieves a row from 'sakila.rental' as a [Rental].
//
// Generated from index 'idx_fk_inventory_id'.
func RentalByInventoryID(ctx context.Context, db DB, inventoryID uint) ([]*Rental, error) {
	// query
	const sqlstr = `SELECT ` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update ` +
		`FROM sakila.rental ` +
		`WHERE inventory_id = ?`
	// run
	logf(sqlstr, inventoryID)
	rows, err := db.QueryContext(ctx, sqlstr, inventoryID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Rental
	for rows.Next() {
		r := Rental{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&r.RentalID, &r.RentalDate, &r.InventoryID, &r.CustomerID, &r.ReturnDate, &r.StaffID, &r.LastUpdate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &r)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// RentalByStaffID retrieves a row from 'sakila.rental' as a [Rental].
//
// Generated from index 'idx_fk_staff_id'.
func RentalByStaffID(ctx context.Context, db DB, staffID uint8) ([]*Rental, error) {
	// query
	const sqlstr = `SELECT ` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update ` +
		`FROM sakila.rental ` +
		`WHERE staff_id = ?`
	// run
	logf(sqlstr, staffID)
	rows, err := db.QueryContext(ctx, sqlstr, staffID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Rental
	for rows.Next() {
		r := Rental{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&r.RentalID, &r.RentalDate, &r.InventoryID, &r.CustomerID, &r.ReturnDate, &r.StaffID, &r.LastUpdate); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &r)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// RentalByRentalDateInventoryIDCustomerID retrieves a row from 'sakila.rental' as a [Rental].
//
// Generated from index 'rental_date'.
func RentalByRentalDateInventoryIDCustomerID(ctx context.Context, db DB, rentalDate time.Time, inventoryID uint, customerID uint16) (*Rental, error) {
	// query
	const sqlstr = `SELECT ` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update ` +
		`FROM sakila.rental ` +
		`WHERE rental_date = ? AND inventory_id = ? AND customer_id = ?`
	// run
	logf(sqlstr, rentalDate, inventoryID, customerID)
	r := Rental{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, rentalDate, inventoryID, customerID).Scan(&r.RentalID, &r.RentalDate, &r.InventoryID, &r.CustomerID, &r.ReturnDate, &r.StaffID, &r.LastUpdate); err != nil {
		return nil, logerror(err)
	}
	return &r, nil
}

// RentalByRentalID retrieves a row from 'sakila.rental' as a [Rental].
//
// Generated from index 'rental_rental_id_pkey'.
func RentalByRentalID(ctx context.Context, db DB, rentalID int) (*Rental, error) {
	// query
	const sqlstr = `SELECT ` +
		`rental_id, rental_date, inventory_id, customer_id, return_date, staff_id, last_update ` +
		`FROM sakila.rental ` +
		`WHERE rental_id = ?`
	// run
	logf(sqlstr, rentalID)
	r := Rental{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, rentalID).Scan(&r.RentalID, &r.RentalDate, &r.InventoryID, &r.CustomerID, &r.ReturnDate, &r.StaffID, &r.LastUpdate); err != nil {
		return nil, logerror(err)
	}
	return &r, nil
}

// Customer returns the Customer associated with the [Rental]'s (CustomerID).
//
// Generated from foreign key 'fk_rental_customer'.
func (r *Rental) Customer(ctx context.Context, db DB) (*Customer, error) {
	return CustomerByCustomerID(ctx, db, r.CustomerID)
}

// Inventory returns the Inventory associated with the [Rental]'s (InventoryID).
//
// Generated from foreign key 'fk_rental_inventory'.
func (r *Rental) Inventory(ctx context.Context, db DB) (*Inventory, error) {
	return InventoryByInventoryID(ctx, db, r.InventoryID)
}

// Staff returns the Staff associated with the [Rental]'s (StaffID).
//
// Generated from foreign key 'fk_rental_staff'.
func (r *Rental) Staff(ctx context.Context, db DB) (*Staff, error) {
	return StaffByStaffID(ctx, db, r.StaffID)
}
