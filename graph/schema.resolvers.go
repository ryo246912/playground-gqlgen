package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"crypto/rand"
	"database/sql"
	"fmt"
	"log"
	"math/big"
	"strings"
	"time"

	"github.com/ryo246912/playground-gqlgen/graph/dataloader"
	"github.com/ryo246912/playground-gqlgen/graph/model"
	"github.com/ryo246912/playground-gqlgen/graph/models"
)

// Email is the resolver for the email field.
func (r *customerResolver) Email(ctx context.Context, obj *model.Customer, mask *bool) (*string, error) {
	if mask == nil || !*mask {
		return &obj.Email, nil
	}

	if !strings.Contains(obj.Email, "SMITH") {
		return &obj.Email, nil
	}

	str := strings.Repeat("*", len(obj.Email))
	return &str, nil
}

// Store is the resolver for the store field.
func (r *customerResolver) Store(ctx context.Context, obj *model.Customer) (*model.Store, error) {
	store, err := dataloader.GetStore(ctx, obj.StoreID)

	if err != nil {
		log.Print("error!", err)
		return nil, err
	}

	return &model.Store{
		ID:         fmt.Sprint(store.StoreID),
		LastUpdate: store.LastUpdate,
		AddressID:  fmt.Sprint(store.AddressID),
	}, nil
}

// Address is the resolver for the address field.
func (r *customerResolver) Address(ctx context.Context, obj *model.Customer) (*model.Address, error) {
	var address models.Address

	err := r.DB.NewSelect().Model(&address).Where("address_id = ?", obj.AddressID).Scan(ctx)
	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	return &model.Address{
		ID:         fmt.Sprint(address.AddressID),
		Address:    address.Address,
		Address2:   nullStringToPtr(address.Address2),
		District:   stringToPtr(address.District),
		CityID:     int32(address.CityID),
		PostalCode: nullStringToPtr(address.PostalCode),
		LastUpdate: address.LastUpdate,
	}, nil
}

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	randNumber, _ := rand.Int(rand.Reader, big.NewInt(100))

	// todo := &model.Todo{
	// 	Text: input.Text,
	// 	ID:   fmt.Sprintf("T%d", randNumber),
	// 	User: &model.User{ID: input.UserID, Name: "user " + input.UserID},
	// }
	// NOTE:userIDをresolveする
	todo := &model.Todo{
		Text:   input.Text,
		ID:     fmt.Sprintf("T%d", randNumber),
		UserID: input.UserID,
	}

	r.todos = append(r.todos, todo)
	return todo, nil
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input model.NewCustomer) (*bool, error) {

	_, err := r.DB.NewInsert().Model(&models.Customer{
		FirstName:  input.FirstName,
		LastName:   input.LastName,
		Email:      sql.NullString{String: input.Email, Valid: input.Email != ""},
		Active:     true,
		CreateDate: time.Now(),
		LastUpdate: sql.NullTime{Time: time.Now(), Valid: true},
		StoreID:    uint8(input.StoreID),
		// 仮でベタ打ち
		AddressID: 605,
	}).Exec(ctx)

	if err != nil {
		log.Println("error!!", err)
		return nil, err
	}

	result := true
	return &result, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	return r.todos, nil
}

// Customers is the resolver for the customers field.
func (r *queryResolver) Customers(ctx context.Context, limit *int32) ([]*model.Customer, error) {
	var customers []models.Customer

	if limit == nil {
		defaultLimit := int32(10)
		limit = &defaultLimit
	}

	err := r.DB.NewSelect().Model(&customers).OrderExpr("customer_id ASC").Limit(int(*limit)).Scan(ctx)
	if err != nil {
		log.Println("error!!", err)
		return nil, err
	}

	res := make([]*model.Customer, len(customers))
	for i, c := range customers {
		res[i] = &model.Customer{
			ID:         fmt.Sprint(c.CustomerID),
			FirstName:  c.FirstName,
			LastName:   c.LastName,
			Email:      *nullStringToPtr(c.Email),
			Active:     c.Active,
			CreateDate: c.CreateDate,
			LastUpdate: nullTimeToPtr(c.LastUpdate),
			StoreID:    fmt.Sprint(c.StoreID),
			AddressID:  fmt.Sprint(c.AddressID),
		}
	}

	return res, nil
}

// ManagerStaffs is the resolver for the managerStaffs field.
func (r *storeResolver) ManagerStaffs(ctx context.Context, obj *model.Store) ([]*model.Staff, error) {
	var staffs []models.Staff

	err := r.DB.NewSelect().Model(&staffs).Where("store_id = ?", obj.ID).Scan(ctx)
	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	res := make([]*model.Staff, len(staffs))
	for i, s := range staffs {
		res[i] = &model.Staff{
			FirstName:  s.FirstName,
			LastName:   s.LastName,
			Email:      nullStringToPtr(s.Email),
			Active:     s.Active,
			UserName:   s.Username,
			LastUpdate: s.LastUpdate,
		}
	}

	return res, nil
}

// Address is the resolver for the address field.
func (r *storeResolver) Address(ctx context.Context, obj *model.Store) (*model.Address, error) {
	var address models.Address

	err := r.DB.NewSelect().Model(&address).Where("address_id = ?", obj.AddressID).Scan(ctx)
	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	return &model.Address{
		ID:         fmt.Sprint(address.AddressID),
		Address:    address.Address,
		Address2:   nullStringToPtr(address.Address2),
		District:   stringToPtr(address.District),
		CityID:     int32(address.CityID),
		PostalCode: nullStringToPtr(address.PostalCode),
		LastUpdate: address.LastUpdate,
	}, nil
}

// User is the resolver for the user field.
// Note:resolver:trueにしたことで新たに生成された関数
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	return &model.User{ID: obj.UserID, Name: "user " + obj.UserID}, nil
}

// Customer returns CustomerResolver implementation.
func (r *Resolver) Customer() CustomerResolver { return &customerResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Store returns StoreResolver implementation.
func (r *Resolver) Store() StoreResolver { return &storeResolver{r} }

// Todo returns TodoResolver implementation.
func (r *Resolver) Todo() TodoResolver { return &todoResolver{r} }

type customerResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type storeResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
