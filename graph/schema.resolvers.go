package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/ryo246912/playground-gqlgen/graph/dataloader"
	"github.com/ryo246912/playground-gqlgen/graph/model"
	"github.com/ryo246912/playground-gqlgen/internal"
)

// Email is the resolver for the email field.
func (r *customerResolver) Email(ctx context.Context, obj *model.Customer, mask *bool) (*string, error) {
	if mask == nil || !*mask {
		return &obj.Email, nil
	}

	if !strings.Contains(obj.Email, "SMITH") {
		return &obj.Email, nil
	}

	str := strings.Repeat("*", len(obj.Email))
	return &str, nil
}

// Store is the resolver for the store field.
func (r *customerResolver) Store(ctx context.Context, obj *model.Customer) (*model.Store, error) {
	store, err := dataloader.GetStore(ctx, obj.StoreID)

	if err != nil {
		log.Print("error!", err)
		return nil, err
	}

	return &model.Store{
		ID:             fmt.Sprint(store.StoreID),
		LastUpdate:     store.LastUpdate,
		AddressID:      fmt.Sprint(store.AddressID),
		ManagerStaffID: fmt.Sprint(store.ManagerStaffID),
	}, nil
}

// Address is the resolver for the address field.
func (r *customerResolver) Address(ctx context.Context, obj *model.Customer) (*model.Address, error) {
	address, err := dataloader.GetAddress(ctx, obj.AddressID)

	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	return &model.Address{
		ID:         fmt.Sprint(address.AddressID),
		Address:    address.Address,
		Address2:   nullStringToPtr(address.Address2),
		District:   stringToPtr(address.District),
		CityID:     int32(address.CityID),
		PostalCode: nullStringToPtr(address.PostalCode),
		LastUpdate: address.LastUpdate,
	}, nil
}

// ManagerStaffs is the resolver for the managerStaffs field.
func (r *storeResolver) ManagerStaffs(ctx context.Context, obj *model.Store) ([]*model.Staff, error) {
	staffs, err := dataloader.GetStaffs(ctx, []string{obj.ID})
	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	res := make([]*model.Staff, len(staffs))
	for i, s := range staffs {
		res[i] = &model.Staff{
			FirstName:  s.FirstName,
			LastName:   s.LastName,
			Email:      nullStringToPtr(s.Email),
			Active:     s.Active,
			UserName:   s.Username,
			LastUpdate: s.LastUpdate,
		}
	}

	return res, nil
}

// Address is the resolver for the address field.
func (r *storeResolver) Address(ctx context.Context, obj *model.Store) (*model.Address, error) {
	address, err := dataloader.GetAddress(ctx, obj.AddressID)

	if err != nil {
		log.Println("error!", err)
		return nil, err
	}

	return &model.Address{
		ID:         fmt.Sprint(address.AddressID),
		Address:    address.Address,
		Address2:   nullStringToPtr(address.Address2),
		District:   stringToPtr(address.District),
		CityID:     int32(address.CityID),
		PostalCode: nullStringToPtr(address.PostalCode),
		LastUpdate: address.LastUpdate,
	}, nil
}

// User is the resolver for the user field.
// Note:resolver:trueにしたことで新たに生成された関数
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	return &model.User{ID: obj.UserID, Name: "user " + obj.UserID}, nil
}

// Customer returns internal.CustomerResolver implementation.
func (r *Resolver) Customer() internal.CustomerResolver { return &customerResolver{r} }

// Store returns internal.StoreResolver implementation.
func (r *Resolver) Store() internal.StoreResolver { return &storeResolver{r} }

// Todo returns internal.TodoResolver implementation.
func (r *Resolver) Todo() internal.TodoResolver { return &todoResolver{r} }

type customerResolver struct{ *Resolver }
type storeResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
