// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package internal

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/ryo246912/playground-gqlgen/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Customer() CustomerResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Store() StoreResolver
	Todo() TodoResolver
}

type DirectiveRoot struct {
	IsAuthenticated func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	Address struct {
		Address    func(childComplexity int) int
		Address2   func(childComplexity int) int
		CityID     func(childComplexity int) int
		District   func(childComplexity int) int
		ID         func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		PostalCode func(childComplexity int) int
	}

	Customer struct {
		Active     func(childComplexity int) int
		Address    func(childComplexity int) int
		CreateDate func(childComplexity int) int
		Email      func(childComplexity int, mask *bool) int
		FirstName  func(childComplexity int) int
		ID         func(childComplexity int) int
		LastName   func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		Store      func(childComplexity int) int
	}

	Mutation struct {
		CreateCustomer func(childComplexity int, input model.NewCustomer) int
		CreateTodo     func(childComplexity int, input model.NewTodo) int
	}

	Query struct {
		Customers func(childComplexity int, limit *int32) int
		Todos     func(childComplexity int) int
	}

	Staff struct {
		Active     func(childComplexity int) int
		Email      func(childComplexity int) int
		FirstName  func(childComplexity int) int
		LastName   func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		UserName   func(childComplexity int) int
	}

	Store struct {
		Address       func(childComplexity int) int
		ID            func(childComplexity int) int
		LastUpdate    func(childComplexity int) int
		ManagerStaffs func(childComplexity int) int
	}

	Todo struct {
		Done func(childComplexity int) int
		ID   func(childComplexity int) int
		Text func(childComplexity int) int
		User func(childComplexity int) int
	}

	User struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Address.address":
		if e.complexity.Address.Address == nil {
			break
		}

		return e.complexity.Address.Address(childComplexity), true

	case "Address.address2":
		if e.complexity.Address.Address2 == nil {
			break
		}

		return e.complexity.Address.Address2(childComplexity), true

	case "Address.cityID":
		if e.complexity.Address.CityID == nil {
			break
		}

		return e.complexity.Address.CityID(childComplexity), true

	case "Address.district":
		if e.complexity.Address.District == nil {
			break
		}

		return e.complexity.Address.District(childComplexity), true

	case "Address.ID":
		if e.complexity.Address.ID == nil {
			break
		}

		return e.complexity.Address.ID(childComplexity), true

	case "Address.lastUpdate":
		if e.complexity.Address.LastUpdate == nil {
			break
		}

		return e.complexity.Address.LastUpdate(childComplexity), true

	case "Address.postalCode":
		if e.complexity.Address.PostalCode == nil {
			break
		}

		return e.complexity.Address.PostalCode(childComplexity), true

	case "Customer.active":
		if e.complexity.Customer.Active == nil {
			break
		}

		return e.complexity.Customer.Active(childComplexity), true

	case "Customer.address":
		if e.complexity.Customer.Address == nil {
			break
		}

		return e.complexity.Customer.Address(childComplexity), true

	case "Customer.createDate":
		if e.complexity.Customer.CreateDate == nil {
			break
		}

		return e.complexity.Customer.CreateDate(childComplexity), true

	case "Customer.email":
		if e.complexity.Customer.Email == nil {
			break
		}

		args, err := ec.field_Customer_email_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Customer.Email(childComplexity, args["mask"].(*bool)), true

	case "Customer.firstName":
		if e.complexity.Customer.FirstName == nil {
			break
		}

		return e.complexity.Customer.FirstName(childComplexity), true

	case "Customer.id":
		if e.complexity.Customer.ID == nil {
			break
		}

		return e.complexity.Customer.ID(childComplexity), true

	case "Customer.lastName":
		if e.complexity.Customer.LastName == nil {
			break
		}

		return e.complexity.Customer.LastName(childComplexity), true

	case "Customer.lastUpdate":
		if e.complexity.Customer.LastUpdate == nil {
			break
		}

		return e.complexity.Customer.LastUpdate(childComplexity), true

	case "Customer.store":
		if e.complexity.Customer.Store == nil {
			break
		}

		return e.complexity.Customer.Store(childComplexity), true

	case "Mutation.createCustomer":
		if e.complexity.Mutation.CreateCustomer == nil {
			break
		}

		args, err := ec.field_Mutation_createCustomer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCustomer(childComplexity, args["input"].(model.NewCustomer)), true

	case "Mutation.createTodo":
		if e.complexity.Mutation.CreateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_createTodo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTodo(childComplexity, args["input"].(model.NewTodo)), true

	case "Query.customers":
		if e.complexity.Query.Customers == nil {
			break
		}

		args, err := ec.field_Query_customers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Customers(childComplexity, args["limit"].(*int32)), true

	case "Query.todos":
		if e.complexity.Query.Todos == nil {
			break
		}

		return e.complexity.Query.Todos(childComplexity), true

	case "Staff.active":
		if e.complexity.Staff.Active == nil {
			break
		}

		return e.complexity.Staff.Active(childComplexity), true

	case "Staff.email":
		if e.complexity.Staff.Email == nil {
			break
		}

		return e.complexity.Staff.Email(childComplexity), true

	case "Staff.firstName":
		if e.complexity.Staff.FirstName == nil {
			break
		}

		return e.complexity.Staff.FirstName(childComplexity), true

	case "Staff.lastName":
		if e.complexity.Staff.LastName == nil {
			break
		}

		return e.complexity.Staff.LastName(childComplexity), true

	case "Staff.lastUpdate":
		if e.complexity.Staff.LastUpdate == nil {
			break
		}

		return e.complexity.Staff.LastUpdate(childComplexity), true

	case "Staff.userName":
		if e.complexity.Staff.UserName == nil {
			break
		}

		return e.complexity.Staff.UserName(childComplexity), true

	case "Store.address":
		if e.complexity.Store.Address == nil {
			break
		}

		return e.complexity.Store.Address(childComplexity), true

	case "Store.id":
		if e.complexity.Store.ID == nil {
			break
		}

		return e.complexity.Store.ID(childComplexity), true

	case "Store.lastUpdate":
		if e.complexity.Store.LastUpdate == nil {
			break
		}

		return e.complexity.Store.LastUpdate(childComplexity), true

	case "Store.managerStaffs":
		if e.complexity.Store.ManagerStaffs == nil {
			break
		}

		return e.complexity.Store.ManagerStaffs(childComplexity), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.text":
		if e.complexity.Todo.Text == nil {
			break
		}

		return e.complexity.Todo.Text(childComplexity), true

	case "Todo.user":
		if e.complexity.Todo.User == nil {
			break
		}

		return e.complexity.Todo.User(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewCustomer,
		ec.unmarshalInputNewTodo,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../graph/schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar DateTime

directive @isAuthenticated on FIELD_DEFINITION

type Customer {
  id: ID!
  firstName: String!
  lastName: String!
  email(mask: Boolean): String
  active: Boolean!
  createDate: DateTime!
  lastUpdate: DateTime
  store: Store
  address: Address
}

type Staff {
  firstName: String!
  lastName: String!
  email: String @isAuthenticated
  active: Boolean!
  userName: String!
  lastUpdate: DateTime!
}

type Address {
  ID: String!
  address: String!
  address2: String
  district: String
  cityID: Int!
  postalCode: String
  lastUpdate: DateTime!
}

type Store {
  id: ID!
  managerStaffs: [Staff!]!
  lastUpdate: DateTime!
  address: Address
}

type Todo {
  id: ID!
  text: String!
  done: Boolean!
  user: User!
}

type User {
  id: ID!
  name: String!
}

type Query {
  todos: [Todo!]!
  customers(limit: Int = 10): [Customer!]!
}

input NewTodo {
  text: String!
  userId: String!
}

input NewCustomer {
  firstName: String!
  lastName: String!
  email: String!
  storeID: Int!
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
  createCustomer(input: NewCustomer!): Boolean
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
